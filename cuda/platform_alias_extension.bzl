"""Module extension for creating platform-specific aliases for external dependencies.

This extension creates repositories with alias targets that select between x86_64 and ARM64
repositories based on the build platform.
"""

load("//cuda/private:templates/registry.bzl", "REGISTRY")

# Use REGISTRY as the source of truth for component targets
TARGET_MAPPING = REGISTRY


def _platform_alias_repo_impl(ctx):
    """Implementation of the platform_alias_repo repository rule.

    Args:
        ctx: Repository context with attributes x86_repo, arm64_repo, and targets.
    """

    # Generate BUILD.bazel content with platform-specific aliases
    build_content = ["# Generated by platform_alias_repo rule", ""]

    # Add load statement for alias
    build_content.append('load("@bazel_skylib//lib:selects.bzl", "selects")')
    build_content.append("")

    # Check if using new dict-based API or old string-based API.
    use_dict_api = len(ctx.attr.linux_x86_64_repos) > 0

    # Build a target for the name of the repo (only if at least one platform is available).
    platform_type = "nvcc" if ctx.attr.component_name in ["nvcc", "nvvm"] else "runtime"

    # Check which platforms are available.
    platforms_available = []
    if use_dict_api:
        if len(ctx.attr.linux_x86_64_repos) > 0:
            platforms_available.append("x86_64")
        if len(ctx.attr.linux_sbsa_repos) > 0:
            platforms_available.append("sbsa")
        if len(ctx.attr.linux_aarch64_repos) > 0:
            platforms_available.append("aarch64")
    else:
        if ctx.attr.linux_x86_64_repo != "":
            platforms_available.append("x86_64")
        if ctx.attr.linux_sbsa_repo != "":
            platforms_available.append("sbsa")
        if ctx.attr.linux_aarch64_repo != "":
            platforms_available.append("aarch64")

    if len(platforms_available) > 0:
        build_content.append("alias(")
        build_content.append('    name = "{}",'.format(ctx.attr.repo_name))
        build_content.append("    actual = select({")
        if "x86_64" in platforms_available:
            build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_x86_64":'.format(platform_type))
            build_content.append('            ":linux_x86_64_{}",'.format(ctx.attr.repo_name))
        if "sbsa" in platforms_available:
            build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_sbsa":'.format(platform_type))
            build_content.append('            ":linux_sbsa_{}",'.format(ctx.attr.repo_name))
        if "aarch64" in platforms_available:
            build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_aarch64":'.format(platform_type))
            build_content.append('            ":linux_aarch64_{}",'.format(ctx.attr.repo_name))
        build_content.append("    }),")
        build_content.append('    visibility = ["//visibility:public"],')
        build_content.append(")")
        build_content.append("")

    # Generate aliases for each platform (only if versions exist for that platform).
    # Check if we have any versions for x86_64.
    has_x86_64 = False
    if use_dict_api:
        has_x86_64 = len(ctx.attr.linux_x86_64_repos) > 0
    else:
        has_x86_64 = ctx.attr.linux_x86_64_repo != ""

    if has_x86_64:
        build_content.append("alias(")
        build_content.append('    name = "linux_x86_64_{}",'.format(ctx.attr.repo_name))
        build_content.append("    actual = select({")
        if use_dict_api:
            for version in ctx.attr.versions:
                if version in ctx.attr.linux_x86_64_repos:
                    repo_name = ctx.attr.linux_x86_64_repos[version]
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}//:{}",'.format(repo_name, ctx.attr.repo_name))

            # Add default for versions where this component doesn't exist.
            build_content.append('        "//conditions:default": "@rules_cuda//cuda/dummy:dummy",')
        else:
            # Old string-based API for backward compatibility.
            for version in ctx.attr.versions:
                build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                build_content.append('            "@{}_{}//:{}",'.format(ctx.attr.linux_x86_64_repo, version.replace(".", "_"), ctx.attr.repo_name))
        build_content.append("    }),")
        build_content.append('    visibility = ["//visibility:public"],')
        build_content.append(")")
        build_content.append("")

    # Check if we have any versions for sbsa.
    has_sbsa = False
    if use_dict_api:
        has_sbsa = len(ctx.attr.linux_sbsa_repos) > 0
    else:
        has_sbsa = ctx.attr.linux_sbsa_repo != ""

    if has_sbsa:
        build_content.append("alias(")
        build_content.append('    name = "linux_sbsa_{}",'.format(ctx.attr.repo_name))
        build_content.append("    actual = select({")
        if use_dict_api:
            for version in ctx.attr.versions:
                if version in ctx.attr.linux_sbsa_repos:
                    repo_name = ctx.attr.linux_sbsa_repos[version]
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}//:{}",'.format(repo_name, ctx.attr.repo_name))

            # Add default for versions where this component doesn't exist.
            build_content.append('        "//conditions:default": "@rules_cuda//cuda/dummy:dummy",')
        else:
            # Old string-based API for backward compatibility.
            for version in ctx.attr.versions:
                build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                build_content.append('            "@{}_{}//:{}",'.format(ctx.attr.linux_sbsa_repo, version.replace(".", "_"), ctx.attr.repo_name))
        build_content.append("    }),")
        build_content.append('    visibility = ["//visibility:public"],')
        build_content.append(")")
        build_content.append("")

    # Check if we have any versions for aarch64.
    has_aarch64 = False
    if use_dict_api:
        has_aarch64 = len(ctx.attr.linux_aarch64_repos) > 0
    else:
        has_aarch64 = ctx.attr.linux_aarch64_repo != ""

    if has_aarch64:
        build_content.append("alias(")
        build_content.append('    name = "linux_aarch64_{}",'.format(ctx.attr.repo_name))
        build_content.append("    actual = select({")
        if use_dict_api:
            for version in ctx.attr.versions:
                if version in ctx.attr.linux_aarch64_repos:
                    repo_name = ctx.attr.linux_aarch64_repos[version]
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}//:{}",'.format(repo_name, ctx.attr.repo_name))

            # Add default for versions where this component doesn't exist.
            build_content.append('        "//conditions:default": "@rules_cuda//cuda/dummy:dummy",')
        else:
            # Old string-based API for backward compatibility.
            for version in ctx.attr.versions:
                build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                build_content.append('            "@{}_{}//:{}",'.format(ctx.attr.linux_aarch64_repo, version.replace(".", "_"), ctx.attr.repo_name))
        build_content.append("    }),")
        build_content.append('    visibility = ["//visibility:public"],')
        build_content.append(")")
        build_content.append("")

    # Only generate target aliases if this component is in TARGET_MAPPING.
    if ctx.attr.component_name not in TARGET_MAPPING:
        # Write the BUILD.bazel file with just the main alias.
        ctx.file("BUILD.bazel", "\n".join(build_content))
        return

    for target in TARGET_MAPPING[ctx.attr.component_name]:
        # Create alias for each target with platform selection (only if platforms are available).
        target_name = target if target.find("/") == -1 else target.split("/")[-1]

        if len(platforms_available) > 0:
            build_content.append("alias(")
            build_content.append('    name = "{}",'.format(target_name))
            build_content.append("    actual = select({")
            if "x86_64" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_x86_64":'.format(platform_type))
                build_content.append('            ":linux_x86_64_{}",'.format(target_name))
            if "sbsa" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_sbsa":'.format(platform_type))
                build_content.append('            ":linux_sbsa_{}",'.format(target_name))
            if "aarch64" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_aarch64":'.format(platform_type))
                build_content.append('            ":linux_aarch64_{}",'.format(target_name))
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

        # Generate platform-specific aliases for this target (only if versions exist).
        if "x86_64" in platforms_available:
            # Determine appropriate dummy target based on the target name.
            dummy_target = "@rules_cuda//cuda/dummy:dummy"
            if target_name == "cicc":
                dummy_target = "@rules_cuda//cuda/dummy:cicc"
            elif target_name == "libdevice.10.bc":
                dummy_target = "@rules_cuda//cuda/dummy:libdevice.10.bc"

            build_content.append("alias(")
            build_content.append('    name = "linux_x86_64_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_x86_64_repos:
                        repo_name = ctx.attr.linux_x86_64_repos[version]
                        build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))

                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": "{}",'.format(dummy_target))
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_x86_64_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

        if "sbsa" in platforms_available:
            build_content.append("alias(")
            build_content.append('    name = "linux_sbsa_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_sbsa_repos:
                        repo_name = ctx.attr.linux_sbsa_repos[version]
                        build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))

                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": "{}",'.format(dummy_target))
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_sbsa_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

        if "aarch64" in platforms_available:
            build_content.append("alias(")
            build_content.append('    name = "linux_aarch64_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_aarch64_repos:
                        repo_name = ctx.attr.linux_aarch64_repos[version]
                        build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))

                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": "{}",'.format(dummy_target))
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda/versions:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_aarch64_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

    # Write the BUILD.bazel file
    ctx.file("BUILD.bazel", "\n".join(build_content))

platform_alias_repo = repository_rule(
    implementation = _platform_alias_repo_impl,
    attrs = {
        "repo_name": attr.string(
            mandatory = True,
            doc = "Original name of the repository",
        ),
        "component_name": attr.string(
            mandatory = True,
            doc = "Name of the component",
        ),
        # New dict-based API (preferred).
        "linux_x86_64_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to x86_64 repository names",
        ),
        "linux_aarch64_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to ARM64/Jetpack repository names",
        ),
        "linux_sbsa_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to SBSA repository names",
        ),
        # Old string-based API (for backward compatibility).
        "linux_x86_64_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for x86_64 platform (deprecated, use linux_x86_64_repos)",
        ),
        "linux_aarch64_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for ARM64/Jetpack platform (deprecated, use linux_aarch64_repos)",
        ),
        "linux_sbsa_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for SBSA platform (deprecated, use linux_sbsa_repos)",
        ),
        "versions": attr.string_list(
            mandatory = True,
            doc = "List of versions to create aliases for",
        ),
    },
)
