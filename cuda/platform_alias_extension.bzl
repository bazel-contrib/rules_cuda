"""Module extension for creating platform-specific aliases for external dependencies.

This extension creates repositories with alias targets that select between x86_64 and ARM64
repositories based on the build platform.
"""

load("//cuda/private:templates/registry.bzl", "REGISTRY")

# Use REGISTRY as the source of truth for component targets
TARGET_MAPPING = REGISTRY


def _platform_alias_repo_impl(ctx):
    """Implementation of the platform_alias_repo repository rule.

    Args:
        ctx: Repository context with attributes x86_repo, arm64_repo, and targets.
    """

    # Generate BUILD.bazel content with platform-specific aliases
    build_content = ["# Generated by platform_alias_repo rule", ""]

    # Add load statement for alias
    build_content.append('load("@rules_cuda//cuda:defs.bzl", "unsupported_cuda_version", "unsupported_cuda_platform")')
    build_content.append("")
    build_content.append('unsupported_cuda_version(name = "unsupported_cuda_version", component = "{}", available_versions = {})'.format(ctx.attr.component_name, ctx.attr.versions))

    # Check if using new dict-based API or old string-based API.
    use_dict_api = len(ctx.attr.linux_x86_64_repos) > 0

    # Build a target for the name of the repo (only if at least one platform is available).
    platform_type = "exec" if ctx.attr.component_name in ["nvcc", "nvvm"] else "target"

    # Check which platforms are available.
    platforms_available = []
    if use_dict_api:
        if len(ctx.attr.linux_x86_64_repos) > 0:
            platforms_available.append("linux-x86_64")
        if len(ctx.attr.linux_sbsa_repos) > 0:
            platforms_available.append("linux-sbsa")
        if len(ctx.attr.linux_aarch64_repos) > 0:
            platforms_available.append("linux-aarch64")
    else:
        if ctx.attr.linux_x86_64_repo != "":
            platforms_available.append("linux-x86_64")
        if ctx.attr.linux_sbsa_repo != "":
            platforms_available.append("linux-sbsa")
        if ctx.attr.linux_aarch64_repo != "":
            platforms_available.append("linux-aarch64")

    if len(platforms_available) > 0:
        build_content.append('unsupported_cuda_platform(name = "unsupported_cuda_platform", component = "{}", available_platforms = {})'.format(ctx.attr.component_name, platforms_available))
        build_content.append("")

    # Only generate target aliases if this component is in TARGET_MAPPING.
    if ctx.attr.component_name not in TARGET_MAPPING:
        # Write the BUILD.bazel file with just the main alias.
        ctx.file("BUILD.bazel", "\n".join(build_content))
        return

    for target in TARGET_MAPPING[ctx.attr.component_name]:
        # Create alias for each target with platform selection (only if platforms are available).
        target_name = target if target.find("/") == -1 else target.split("/")[-1]

        if len(platforms_available) > 0:
            build_content.append("alias(")
            build_content.append('    name = "{}",'.format(target_name))
            build_content.append("    actual = select({")
            if "linux-x86_64" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_x86_64":'.format(platform_type))
                build_content.append('            ":linux_x86_64_{}",'.format(target_name))
            if "linux-sbsa" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_sbsa":'.format(platform_type))
                build_content.append('            ":linux_sbsa_{}",'.format(target_name))
            if "linux-aarch64" in platforms_available:
                build_content.append('        "@rules_cuda//cuda:{}_platform_is_linux_aarch64":'.format(platform_type))
                build_content.append('            ":linux_aarch64_{}",'.format(target_name))
            build_content.append('        "//conditions:default": ":unsupported_cuda_platform",')
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")


        # Determine appropriate dummy target based on the target name.
        dummy_target = "@rules_cuda//cuda/dummy:dummy"
        if target_name == "cicc":
            dummy_target = "@rules_cuda//cuda/dummy:cicc"
        elif target_name == "libdevice.10.bc":
            dummy_target = "@rules_cuda//cuda/dummy:libdevice.10.bc"

        # Generate platform-specific aliases for this target (only if versions exist).
        if "linux-x86_64" in platforms_available:
            build_content.append("alias(")
            build_content.append('    name = "linux_x86_64_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_x86_64_repos:
                        repo_name = ctx.attr.linux_x86_64_repos[version]
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))
                    else:
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "{}",'.format(dummy_target))
                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_x86_64_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

        if "linux-sbsa" in platforms_available:
            build_content.append("alias(")
            build_content.append('    name = "linux_sbsa_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_sbsa_repos:
                        repo_name = ctx.attr.linux_sbsa_repos[version]
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))
                    else:
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "{}",'.format(dummy_target))

                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_sbsa_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

        if "linux-aarch64" in platforms_available:
            build_content.append("alias(")
            build_content.append('    name = "linux_aarch64_{}",'.format(target_name))
            build_content.append("    actual = select({")
            if use_dict_api:
                for version in ctx.attr.versions:
                    if version in ctx.attr.linux_aarch64_repos:
                        repo_name = ctx.attr.linux_aarch64_repos[version]
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "@{}//{}",'.format(repo_name, target if target.find(":") != -1 else ":" + target))
                    else:
                        build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                        build_content.append('            "{}",'.format(dummy_target))
                # Add default for versions where this component doesn't exist.
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            else:
                # Old string-based API for backward compatibility.
                for version in ctx.attr.versions:
                    build_content.append('        "@rules_cuda//cuda:version_is_{}": '.format(version.replace(".", "_")))
                    build_content.append('            "@{}_{}//{}",'.format(ctx.attr.linux_aarch64_repo, version.replace(".", "_"), target if target.find(":") != -1 else ":" + target))
                build_content.append('        "//conditions:default": ":unsupported_cuda_version",')
            build_content.append("    }),")
            build_content.append('    visibility = ["//visibility:public"],')
            build_content.append(")")
            build_content.append("")

    # Write the BUILD.bazel file
    ctx.file("BUILD.bazel", "\n".join(build_content))

platform_alias_repo = repository_rule(
    implementation = _platform_alias_repo_impl,
    attrs = {
        "repo_name": attr.string(
            mandatory = True,
            doc = "Original name of the repository",
        ),
        "component_name": attr.string(
            mandatory = True,
            doc = "Name of the component",
        ),
        # New dict-based API (preferred).
        "linux_x86_64_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to x86_64 repository names",
        ),
        "linux_aarch64_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to ARM64/Jetpack repository names",
        ),
        "linux_sbsa_repos": attr.string_dict(
            default = {},
            doc = "Dictionary mapping versions to SBSA repository names",
        ),
        # Old string-based API (for backward compatibility).
        "linux_x86_64_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for x86_64 platform (deprecated, use linux_x86_64_repos)",
        ),
        "linux_aarch64_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for ARM64/Jetpack platform (deprecated, use linux_aarch64_repos)",
        ),
        "linux_sbsa_repo": attr.string(
            default = "",
            doc = "Base name of the repository to use for SBSA platform (deprecated, use linux_sbsa_repos)",
        ),
        "versions": attr.string_list(
            mandatory = True,
            doc = "List of versions to create aliases for",
        ),
    },
)
